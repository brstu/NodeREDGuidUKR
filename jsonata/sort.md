## Сортування, групування і агрегація 

### Сортування

​      Масиви містять впорядкований набір значень. Якщо потрібно змінити порядок значень, то масив необхідно відсортувати. У JSONata існує два способи сортування масиву:

1. Використовуючи функцію [`$sort()`](http://docs.jsonata.org/array-functions#sort).

2. Використовуючи оператор [order-by](http://docs.jsonata.org/control-operators#order-by) ( ^(...) ).


Оператор [order-by](http://docs.jsonata.org/control-operators#order-by) є зручним синтаксисом, який може використовуватися безпосередньо у виразі шляху для сортування послідовностей результатів у порядку зростання або спадання. Функція [`$sort()`](http://docs.jsonata.org/array-functions#sort)вимагає більше синтаксису для запису, але є більш гнучкою і підтримує функції користувацьких компараторів.

У таблиці 11.11 показні приклади використання функції і оператору сортування. Можна перевірити ці приклади, перейшовши на сайт http://try.jsonata.org/ (виберіть приклад Address).

```json
{
"Phone": [
    {
      "type": "home",
      "number": "0203 544 1234"
    },
    {
      "type": "office",
      "number": "01962 001234"
    },
    {
      "type": "office",
      "number": "01962 001235"
    },
    {
      "type": "mobile",
      "number": "077 7700 1234"
    }
  ]
}
```

Таблиця 11.11.

| **JSONata**                                                  | **Result**                                                   | **Коментар**                                            |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------- |
| `Phone^(>number)`                                            | `[`` {``  "type": "mobile",``  "number": "077 7700 1234"`` },`` {``  "type": "home",``  "number": "0203 544 1234"`` },`` {``  "type": "office",``  "number": "01962 001235"`` },`` {``  "type": "office",``  "number": "01962 001234"`` }``]` | В порядку спадання поля number                          |
| `$sort(Phone, function($l, $r) {`  `   $substring($l.number,1,3) > $substring($r.number,1,3)`  `})` | `[`  ` {`  `    "type": "office",`  `    "number": "01962 001234"`  ` },`  ` {`  `    "type": "office",`  `    "number": "01962 001235"`  ` },`  ` {`  `    "type": "home",`  `    "number": "0203 544 1234"`  ` },`  ` {`  `    "type": "mobile",`  `    "number": "077 7700 1234"`  ` }`  `]` | В порядку зростання 3-х  перших символів поля `number ` |

### Групування

​      Синтаксис конструктора об'єктів JSONata дозволяє вказувати вираз для означення ключа в будь-якій парі ключ/значення (значення, очевидно, також може бути виразом). Вираз ключа повинен бути рядком. Результат кожної пари виразів ключ/значення вставляється в результуючий об'єкт JSON. Якщо оцінка будь-якого виразу для ключа призводить до того, що ключ вже є в об'єкті результату, то результат цього виразу буде згруповано з значенням, яке вже пов'язано з цим ключем. Зауважте, що значення виразу не оцінюються, доки не буде виконано все групування, це дозволяє оцінювати вирази агрегації по колекції елементів для кожної групи.

Таблиця 11.12.

див. http://try.jsonata.org/ (приклад Invoice)

| **JSONata**                                                  | **Result**                                                   |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| `Account.Order.Product{`Product Name`: Price}`` `            | `{   "Bowler Hat": [ 34.45, 34.45 ],   "Trilby hat": 21.67,   "Cloak": 107.99  }`` ` |
| `Account.Order.Product {   `Product Name`: {"Price": Price, "Qty": Quantity}  }`` ` | `{   "Bowler Hat": {    "Price": [ 34.45, 34.45 ],    "Qty": [ 2, 4 ]   },   "Trilby hat": { "Price": 21.67, "Qty": 1 },   "Cloak": { "Price": 107.99, "Qty": 1 }  }`` ` |

Зверніть увагу, що у наведеному вище прикладі вираз значення об'єднав усі ціни разом і всі величини разом у окремі масиви. Це пояснюється тим, що значення контексту - це послідовність всіх згрупованих продуктів, а вираз `Price` вибирає всі ціни з усіх продуктів. Якщо ви хочете зібрати ціну і кількість в окремі об'єкти, то вам необхідно оцінити конструктор об'єкта *for each* продукту в послідовності контексту. Наступний приклад показує це.

Таблиця 11.13.

див. http://try.jsonata.org/ (приклад Invoice)

| **JSONata**                                                  | **Result**                                                   | **Примітки**                                                 |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| `Account.Order.Product {   `Product Name`: $.{"Price": Price, "Qty": Quantity}  }`` ` | `{   "Bowler Hat": [    { "Price": 34.45, "Qty": 2 },    { "Price": 34.45, "Qty": 4 }   ],   "Trilby hat": { "Price": 21.67, "Qty": 1 },   "Cloak": { "Price": 107.99, "Qty": 1 }  }`` ` | Явне використання $.{  ... } для створення об’єкта для кожного елементу в групі |
| `Account.Order.Product{`Product Name`: $.(Price*Quantity)}`` ` | `{   "Bowler Hat": [ 68.9, 137.8 ],   "Trilby hat": 21.67,   "Cloak": 107.99  }` | Множить ціну на кількість для кожного продукту в кожній групі |

### Агрегація

​      Часто запити просто потрібні для повернення агрегованих результатів з набору відповідних значень. Доступно ряд функцій агрегації, які повертають єдине агреговане значення при застосуванні до масиву значень.

Таблиця 11.14.

див. http://try.jsonata.org/ (приклад Invoice)

| **JSONata**                                       | **Result** |
| ------------------------------------------------- | ---------- |
| `$sum(Account.Order.Product.Price)`` `            | `198.56 `  |
| `$sum(Account.Order.Product.(Price*Quantity))`` ` | `336.36 `  |

Числові функції [агрегації](http://docs.jsonata.org/aggregation-functions) доступні за [посиланням](http://docs.jsonata.org/aggregation-functions).

