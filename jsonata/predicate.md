[<- На головну](../)  [Розділ](README.md)

## 11.3. Предикативні запити (Predicate Queries) 

### Предикати

На будь-якому кроці шляху розташування виділені елементи можуть бути відфільтровані за допомогою **предиката** - `[expr]`, де `expr` аналізується як вираз, що повертає булеве значення. Кожен елемент у виділенні перевіряється як вираз, якщо він дорівнює `true`, то елемент залишається у виділенні, якщо `false`, він видаляється з виділення. Вираз оцінюється відносно поточного (контекстного) елемента, що перевіряється, тому, якщо вираз предиката виконує навігацію, то вона проводиться відносно цього контексту.

У таблиці 11.3 показні приклади предикатів. Можна перевірити ці приклади, перейшовши на сайт `http://try.jsonata.org/ (виберіть приклад Address).

Приклад:

```json
{"Phone": [
{"type": "home",
"number": "0203 544 1234"
},
{"type": "office",
"number": "01962 001234"
},
{"type": "office",
"number": "01962 001235"},
{"type": "mobile",
"number": "077 7700 1234"
}]}
```

Таблиця 11.3.

| **JSONata**                      | **Result**                                          | **Коментар**                                         |
| -------------------------------- | --------------------------------------------------- | ---------------------------------------------------- |
| `Phone[type='mobile']`` `        | `{"type": "mobile", "number": "077 7700 1234" }`` ` | Вибирає елементи Phone, у яких є поле типу "mobile". |
| `Phone[type='mobile'].number`    | `"077 7700 1234"`` `                                | вибір номерів мобільних телефонів                    |
| `Phone[type='office'].number`` ` | `["01962 001234", "01962 001235"]`` `               | вибір офісних мобільних телефонів                    |

### Одноелементний масив і еквівалентність значень

У виразі або підвиразі JSONata будь-яке значення (яке не є масивом) і масив, що містить тільки це значення, вважаються еквівалентними. Це дозволяє складати композицію таким чином, щоб шляхи розташування, які витягують одне значення з об'єктів і шляхи розташування, які витягують декілька значень з масивів, можуть бути використані як вхідні дані для інших виразів без використання іншого синтаксису для двох форм. 

Наприклад (див вихідний текс JSON вище):

- `Address.City` повертає `"Winchester"`
- `Phone[0].number`  повертає `"0203 544 1234"`
- `Phone[type='home'].number`  повертає `"0203 544 1234"`
- `Phone[type='office'].number` повертає`["01962 001234", "01962 001235"]`

При наступній обробці поверненого з вираження JSONata значення, може бути бажаним мати результати в узгодженому форматі, незалежно від того, скільки співпадінь було і відповідно який формат поверненого значення (масив або одне значення). У перших двох виразах вище, очевидно, що кожен вираз звертається до одного значення в структурі і має сенс повернути саме це значення. В останніх двох виразах, однак, не є очевидним, скільки значень буде повернено, тому при наступній обробці прийдеться враховувати різні формати, що не є зручним. 

Для таких випадків вираз можна змінити таким чином, щоб повернути масив, навіть якщо збігається лише одне значення. Це робиться шляхом додавання порожніх квадратних дужок *[]* до кроку в шляху розташування. Наведені вище приклади можуть бути переписані так, щоб завжди повертати масив, це виглядає наступним чином:

- `Address[].City` повертає `[ "Winchester"]`
- `Phone[0][].number` повертає `[ "0203 544 1234" ]`
- `Phone[][type='home'].number` повертає `[ "0203 544 1234" ]`
- `Phone[type='office'].number[] `повертає `[ "01962 001234", "01962 001235" ]`

Зауважимо, що `[]` можна розмістити у будь-якому місці предикатів і на будь-якому кроці вираження шляху

### Шаблони заміни

Використовуйте `*` замість імені поля для вибору всіх полів в об'єкті. У таблиці 11.4 показні приклади предикату `*`. Можна перевірити ці приклади, перейшовши на сайт http://try.jsonata.org/ (виберіть приклад Address).

Приклад:

```json
{
  "FirstName": "Fred",
  "Surname": "Smith",
  "Age": 28,
  "Address": {
    "Street": "Hursley Park",
    "City": "Winchester",
    "Postcode": "SO21 2JN"
  }
}
```

 

Таблиця 11.4.

| **JSONata**     | **Result**                                        |
| --------------- | ------------------------------------------------- |
| `Address.*`` `  | `[ "Hursley Park", "Winchester", "SO21 2JN" ]`` ` |
| `*.Postcode`` ` | `"SO21 2JN"`` `                                   |

 Шаблон нащадка `**` замість `*` буде відбирати всіх нащадків (багаторівневий шаблон).    

Для прикладу з таблиці 11.1 

`**.Postcode` поверне `[ "SO21 2JN", "E1 6RF" ]`